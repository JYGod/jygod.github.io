<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>深入Lua - 字符串 | Teddyjiang的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入Lua - 字符串</h1><a id="logo" href="/.">Teddyjiang的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深入Lua - 字符串</h1><div class="post-meta">Jun 23, 2019<span> | </span><span class="category"><a href="/categories/Lua/">Lua</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.1k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 5</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串结构定义"><span class="toc-number">1.</span> <span class="toc-text">字符串结构定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串缓存"><span class="toc-number">2.</span> <span class="toc-text">字符串缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建字符串"><span class="toc-number">3.</span> <span class="toc-text">创建字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩容"><span class="toc-number">4.</span> <span class="toc-text">扩容</span></a></li></ol></div></div><div class="post-content"><p>该篇文章将从Lua string的底层代码去分析字符串是如何创建、缓存、以及扩容的，深入分析了Lua字符串的整个工作原理。</p>
<h1 id="字符串结构定义"><a href="#字符串结构定义" class="headerlink" title="字符串结构定义"></a>字符串结构定义</h1><p>Lua中字符串结构体定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br><span class="line"><span class="comment">** included in other objects)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CommonHeader	GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Header for string value; string bytes follow the end of this structure</span></span><br><span class="line"><span class="comment">** (aligned according to 'UTString'; see next).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; "has hash" for longs */</span></span><br><span class="line">  lu_byte shrlen;  <span class="comment">/* length for short strings */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> lnglen;  <span class="comment">/* length for long strings */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">/* linked list for hash table */</span></span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; TString;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Ensures that address after this type is always fully aligned.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> UTString &#123;</span><br><span class="line">  L_Umaxalign dummy;  <span class="comment">/* ensures maximum alignment for strings */</span></span><br><span class="line">  TString tsv;</span><br><span class="line">&#125; UTString;</span><br></pre></td></tr></table></figure>

<h1 id="字符串缓存"><a href="#字符串缓存" class="headerlink" title="字符串缓存"></a>字符串缓存</h1><p>在创建字符串时，首先会从global_State的strcache缓存中查找看是否存在:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2952813-44b34dcfd6c335f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strcache结构.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define STRCACHE_N		53</span></span><br><span class="line"><span class="comment">// #define STRCACHE_M		2</span></span><br><span class="line"></span><br><span class="line"><span class="function">TString *<span class="title">luaS_new</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = point2uint(str) % STRCACHE_N;  <span class="comment">/* hash */</span></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  TString **p = G(L)-&gt;strcache[i];</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; STRCACHE_M; j++) &#123;</span><br><span class="line">    <span class="comment">// strcmp == 0，两个str相同</span></span><br><span class="line">    <span class="comment">// getstr --&gt; TString转string</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str, getstr(p[j])) == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> p[j]; <span class="comment">// 找到相同str</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (j = STRCACHE_M - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">    p[j] = p[j - <span class="number">1</span>]; <span class="comment">// 移动元素</span></span><br><span class="line">  <span class="comment">// 新元素会插入到list最前端</span></span><br><span class="line">  p[<span class="number">0</span>] = luaS_newlstr(L, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">  <span class="keyword">return</span> p[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个字符串的时候，首先会在strcache中查找，第7行根据str计算出该str在strcache的索引位置，在该strcache位置上又有一个大小为2( STRCACHE_M )的TString数组，若在这个数组中找到相同的字符串，则返回cache中字符串对应的TString；若未找到，会将p[0]位置的TString挪到p[1]位置，而p[0]位置存放<code>luaS_newlstr</code>新创建的TString。</p>
<h1 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define LUAI_MAXSHORTLEN	40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** new string (with explicit length)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TString *<span class="title">luaS_newlstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= LUAI_MAXSHORTLEN)  <span class="comment">/* short string? */</span></span><br><span class="line">    <span class="keyword">return</span> internshrstr(L, str, l);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    TString *ts;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= (MAX_SIZE - <span class="keyword">sizeof</span>(TString))/<span class="keyword">sizeof</span>(<span class="keyword">char</span>))</span><br><span class="line">      luaM_toobig(L);</span><br><span class="line">    ts = luaS_createlngstrobj(L, l);</span><br><span class="line">    <span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个TString时，会判断字符串长度是否大于40( LUAI_MAXSHORTLEN )，对于长度大于40的str，会直接创建TString并返回，而对于长度40以内的short string，会从global_State中的一个stringtable(strt)查找并记录:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** checks whether short string exists and reuses it or creates a new one</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TString *<span class="title">internshrstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">  TString *ts;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">  TString **<span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];</span><br><span class="line">  lua_assert(str != <span class="literal">NULL</span>);  <span class="comment">/* otherwise 'memcmp'/'memcpy' are undefined */</span></span><br><span class="line">  <span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;u.hnext) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == ts-&gt;shrlen &amp;&amp;</span><br><span class="line">        (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)) == <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">/* found! */</span></span><br><span class="line">      <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br><span class="line">        changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br><span class="line">      <span class="keyword">return</span> ts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// list中如果没找到</span></span><br><span class="line">  <span class="comment">// resize 扩容</span></span><br><span class="line">  <span class="keyword">if</span> (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/<span class="number">2</span>) &#123;</span><br><span class="line">    luaS_resize(L, g-&gt;strt.size * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];  <span class="comment">/* recompute with new size */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不需要扩容的情况</span></span><br><span class="line">  ts = createstrobj(L, l, LUA_TSHRSTR, h);</span><br><span class="line">  <span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  ts-&gt;shrlen = cast_byte(l);</span><br><span class="line">  ts-&gt;u.hnext = *<span class="built_in">list</span>;</span><br><span class="line">  *<span class="built_in">list</span> = ts;</span><br><span class="line">  g-&gt;strt.nuse++;</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>strt的数据结构类似于HashMap，它的初始化的数组长度为128，首先根据str计算得到的hash值(0~127),找到数组对应的下标索引，取出对应下标的list链表，10 ~ 18行是对该list进行遍历，若找到则直接返回；如未找到，则继续向下走。第21行， 如果 nuse(当前strt中TSring总数) 超过容量size(初始128)值，就会进行<code>luaS_resize</code>扩容操作(后续细讲)，strt的容量将扩为原来的2倍。如果不需要扩容，第26行开始，会创建一个新的TString，并将其插入到当前list的头部。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2952813-fefca9de2b7e2015.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strt结构.png"></p>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** resizes the string table</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaS_resize</span> <span class="params">(lua_State *L, <span class="keyword">int</span> newsize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  stringtable *tb = &amp;G(L)-&gt;strt;</span><br><span class="line">  <span class="keyword">if</span> (newsize &gt; tb-&gt;size) &#123;  <span class="comment">/* grow table if needed */</span></span><br><span class="line">    luaM_reallocvector(L, tb-&gt;hash, tb-&gt;size, newsize, TString *);</span><br><span class="line">    <span class="keyword">for</span> (i = tb-&gt;size; i &lt; newsize; i++)</span><br><span class="line">      tb-&gt;hash[i] = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tb-&gt;size; i++) &#123;  <span class="comment">/* rehash */</span></span><br><span class="line">    TString *p = tb-&gt;hash[i];</span><br><span class="line">    tb-&gt;hash[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;  <span class="comment">// 遍历每一个节点</span></span><br><span class="line">      TString *hnext = p-&gt;u.hnext; </span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> h = lmod(p-&gt;hash, newsize); </span><br><span class="line">      p-&gt;u.hnext = tb-&gt;hash[h];</span><br><span class="line">      tb-&gt;hash[h] = p;</span><br><span class="line">      p = hnext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newsize &lt; tb-&gt;size) &#123;  <span class="comment">/* shrink table if needed */</span></span><br><span class="line">    <span class="comment">/* vanishing slice should be empty */</span></span><br><span class="line">    lua_assert(tb-&gt;hash[newsize] == <span class="literal">NULL</span> &amp;&amp; tb-&gt;hash[tb-&gt;size - <span class="number">1</span>] == <span class="literal">NULL</span>);</span><br><span class="line">    luaM_reallocvector(L, tb-&gt;hash, tb-&gt;size, newsize, TString *);</span><br><span class="line">  &#125;</span><br><span class="line">  tb-&gt;size = newsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第7行，如果需要扩容，则调用<code>luaM_reallocvector</code>将 tb-&gt;hash 数组扩大到newsize (2倍)，12行~22行对每一个数组位置list链表中每一个TString节点的元素<strong>重新计算hash值</strong>，并将其插入到对应数组中的链表头部位置处。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>teddyjiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/06/23/深入Lua-字符串/">https://teddyjiang.github.io/2019/06/23/深入Lua-字符串/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>复制或引用请注明出处</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://teddyjiang.github.io/2019/06/23/深入Lua-字符串/" data-id="cjx8je2gg0000evshk4bl4hy4" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACHklEQVR42u3aQW7DMAwEwP7/0ynQaxBhV3JShB6dikaxPT4wpMifn3g9/tbzf9ZrvT//9LKFgYHxtYzkUa5iPH93zcivj4GBcQfGOsiekNaMZGfyA4CBgYHRhuD8peztxMDAwNi73DodTF4NBgYGxpqRpGv5DfL9/1CLY2BgfCGjbQx88u839jcwMDC+hPHYWklaed7+LJ4HAwNjNCM5JstDcDtOcVUyioGBcQfGCa89Pkt2JsVq8eoxMDBGMK4qLPMDuLe3MDEwMMYx8luejF8kYbf9lXiJwcDAGM1IbtAG3zy8nrxWDAyMqYw2UcsPztbfzRPTZPwCAwNjNuOTRWwbXvMmBAYGxh0Ye8f3bSmbBOsL0lMMDIxxjPyALD96y4cw9sY7Xma4GBgYQxlXpWt7jYG94F5nphgYGEMZe4f1eznpSWsTAwMDo324fJi1XdGPBAYGxlBGW3C2I1wnjOLQDQMDYzQjScjag7bz4ra9LwYGxh0YJ0VsHnDbpkLdPMDAwLgZYy8EJyMX+eBFezUMDIzZjDbUtiE7xx8NW2BgYAxl7B3QF+naVlJYF7EYGBijGXuP0hai58F6r9jGwMCYxGiDbJvMnbc5i5kRDAyM0Yw2pUuCb57q7RWxGBgYGCcDFudN07pkxcDAwIiPxtoGZDtmUfc0MDAwBjGSR0l25kVv29SMAi4GBsZQxnkbcu9qbYp5npJiYGB8IeMXT3ZqmKHFXPsAAAAASUVORK5CYII=">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/06/23/NGUI的面板绘制原理/">NGUI的面板绘制原理</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'cf798d30d92e03b58c26',
  clientSecret: '4d72762fd21fa367c3c9836b9641301ea3272650',
  repo: 'gittalk.github.io',
  owner: 'JYGod',
  admin: ['JYGod'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://teddyjiang.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Lua/">Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NGUI/">NGUI</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/23/NGUI的面板绘制原理/">NGUI的面板绘制原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/23/深入Lua-字符串/">深入Lua - 字符串</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/jygod/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://www.jianshu.com/u/b4d7ac8c1b81" title="简书" target="_blank">简书</a><ul></ul><a href="https://github.com/JYGod" title="Github" target="_blank">Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Teddyjiang的技术博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>