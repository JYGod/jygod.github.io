<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>NGUI的面板绘制原理 | Teddyjiang的技术博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">NGUI的面板绘制原理</h1><a id="logo" href="/.">Teddyjiang的技术博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">NGUI的面板绘制原理</h1><div class="post-meta">Jun 23, 2019<span> | </span><span class="category"><a href="/categories/NGUI/">NGUI</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 6</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础知识介绍"><span class="toc-number">1.</span> <span class="toc-text">基础知识介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#相关组件"><span class="toc-number">1.1.</span> <span class="toc-text">相关组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染层级的决定因素"><span class="toc-number">1.2.</span> <span class="toc-text">渲染层级的决定因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DrawCall-Batching技术"><span class="toc-number">1.3.</span> <span class="toc-text">DrawCall Batching技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIPanel、UIWidget、UIGeometry和UIDrawcall的关系"><span class="toc-number">2.</span> <span class="toc-text">UIPanel、UIWidget、UIGeometry和UIDrawcall的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIPanel的工作原理"><span class="toc-number">3.</span> <span class="toc-text">UIPanel的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UIPanel-AddWidget"><span class="toc-number">3.1.</span> <span class="toc-text">UIPanel.AddWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIPanel-LateUpdate"><span class="toc-number">3.2.</span> <span class="toc-text">UIPanel.LateUpdate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FillAllDrawCalls"><span class="toc-number">3.2.1.</span> <span class="toc-text">FillAllDrawCalls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FillDrawCall"><span class="toc-number">3.2.2.</span> <span class="toc-text">FillDrawCall</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#减少DrawCall数量的建议"><span class="toc-number">3.3.</span> <span class="toc-text">减少DrawCall数量的建议</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="基础知识介绍"><a href="#基础知识介绍" class="headerlink" title="基础知识介绍"></a>基础知识介绍</h1><h2 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h2><p>在介绍NGUI的面板绘制原理前，需要提前对一些NGUI的组件进行了解。</p>
<ul>
<li>UIPanel: 管理他下面所有Widget，窗口的裁剪，以及指派DrawCall的创建与更新</li>
<li>UIWidget：一种矩形容器组件，是UILabel、UITexture、UISprite、和UI2DSprite的基类</li>
<li>UIGeometry：是UIWidget的几何数据，记录了顶点坐标、贴图的UVs和颜色等信息</li>
<li>Mesh：需要被绘制的元素都需要Mesh网格组件，其中包含顶点、UV、Color、切线、法线、三角面信息</li>
<li>MeshFilter：网格过滤器，会从资源中获取Mesh信息，并将其传递给网格渲染器进行渲染</li>
<li>MeshRenderer：网格渲染器，用于渲染网格。若MeshRenderer组件被移除，将不会渲染该网格</li>
</ul>
<h2 id="渲染层级的决定因素"><a href="#渲染层级的决定因素" class="headerlink" title="渲染层级的决定因素"></a>渲染层级的决定因素</h2><p>a) Camera.Depth: 相机的Depth值越大，渲染的图像越靠前，优先级最高</p>
<p>b) render.sortingOrder: 修改UIPanel的sort order值，相当于改了其中DrawCalls的sortingOrder值，也就是改变了Renderer的sortingOrder值</p>
<p>c) Render Queue: Material和Shader都有该属性，它的值一般是从3000开始的，每新创建一个UIDrawcall，其对应material的render queue的值就会加1，因此UIDrawcall是靠render queue排序的</p>
<p>d) 顶点缓存序列的先后: 即UIGeometry中传递的vertex序列，UIWidget在遍历排序时，通过一定的排序算法，在列表中靠前位置的Widget的vertex会先传入UIGeometry缓存中，因此该vertex在传入UIDrawcall后会优先生成Mesh并渲染</p>
<p>UIPanel和UIWidget都有一个depth属性，共同决定着组件的最终深度值，而NGUI中主要就是根据这个深度值的顺序去进行渲染。一般情况下，UIPanel的depth权重远远高于UIWidget的depth权重。</p>
<h2 id="DrawCall-Batching技术"><a href="#DrawCall-Batching技术" class="headerlink" title="DrawCall Batching技术"></a>DrawCall Batching技术</h2><p>在Unity中，每次引擎准备数据并通知GPU的过程称为一次Drawcall。Unity的DrawCall Batching（合批处理）技术，目标是在一次DrawCall的过程中批量处理多个物体。只要物体的材质相同，GPU就可以按照相同的方式进行处理，因此可以将其合并为一个DrawCall进行处理。</p>
<h1 id="UIPanel、UIWidget、UIGeometry和UIDrawcall的关系"><a href="#UIPanel、UIWidget、UIGeometry和UIDrawcall的关系" class="headerlink" title="UIPanel、UIWidget、UIGeometry和UIDrawcall的关系"></a>UIPanel、UIWidget、UIGeometry和UIDrawcall的关系</h1><p>在了解NGUI的面板绘制原理前，先用一张图列出各组件间的关系，</p>
<p><img src="%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p>
<p>每个UIPanel只负责管理它下面所有的Widget，根据Widget的深度值进行排序，然后对有序的Widget列表中材质相同的相邻Widget进行DrawCall的合并。</p>
<p>UIPanel负责管理UIWidget和UIDrawcall的列表，控制UIWidget的插入、调整等操作。</p>
<p>当插入UIWidget时，根据一定规则将UIWidget插入到Widget列表的相应位置中，然后根据UIWidget的深度、材质和位置关系判断是复用DrawCall还是创建新的DrawCall。</p>
<p>UIDrawCall相当于对DrawCall进行了一层封装，它能完成一些比如创建和更新材质、从Geometry中获取缓存数据并添加网格相关的组件、对网格数据进行设置等工作，从而完成面板的渲染。</p>
<p>每一个UIWidget都对应一个UIGeometry，UIGeometry用于记录widget的顶点信息、UVs、颜色信息等。当UIWidget有变动时都会刷新Geometry中的数据。在UIPanel的LateUpdate生命周期回调中，会指派所有UIDrawcall去对相应Mesh网格进行数据的填充，从而完成绘制工作。</p>
<h1 id="UIPanel的工作原理"><a href="#UIPanel的工作原理" class="headerlink" title="UIPanel的工作原理"></a>UIPanel的工作原理</h1><p>为了深入了解NGUI中面板的绘制流程，我们必须明白UIPanel的工作原理。</p>
<p>在UIPanel中有两个比较重要的数据变量:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2952813-fad8f9970723bfe7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>其中，widgets是一个有序的UIWidget的列表，通过搜索可知，唯一一处调用<code>list.Add()</code>或<code>list.Insert()</code>地方是在UIPanel的<code>UIPanel.AddWidget()</code>方法中，而调用<code>UIPanel.AddWidget()</code>的地方有<code>UIWidget.CreatePanel()</code> 和UIWidget中depth属性的set方法。</p>
<p>drawCalls是UIPanel中持有的一个记录该Panel中所有DrawCall的列表，在有新的DrawCall产生时都会将其插入到drawCalls中。在添加新的DrawCall或更新DrawCall是都会通知Geometry刷新数据。在UIPanel的LateUpdate的最后都会为所有面板的DrawCall设置正确的renderQueue值，从而能根据该值进行正确顺序的渲染。</p>
<p>在介绍UIPanel的工作原理时，主要从两个重要的方法入手（UIPanel.AddWidget和UIPanel.LateUpdate）。</p>
<h2 id="UIPanel-AddWidget"><a href="#UIPanel-AddWidget" class="headerlink" title="UIPanel.AddWidget"></a>UIPanel.AddWidget</h2><p><code>panel.AddWidget(w)</code>方法会向widgets中插入Widget。</p>
<p>在向widgets中插入Widget时，会根据<code>UIWidget.PanelCompareFunc()</code>比较目标Widget，然后将当前Widget插入到符合条件的位置。</p>
<p><strong>UIWidget.PanelCompareFunc()比较方法的规则如下:</strong></p>
<p>① Widget的depth值小的在前，depth值大的在后</p>
<p>② 若depth相同，则优先有material的widget在前</p>
<p>③ 若depth相同且都有material，则material的instance id值小的在前</p>
<p>在将widget插入到widgets的合理位置后，会进行<code>FindDrawCall(w)</code>，在这个过程中，会遍历整个UIPanel中的drawcalls，如果widget满足要求，则复用现有的DrawCall；若不满足要求，则需要创建一个新的DrawCall。</p>
<p><strong>FindDrawCall复用已有drawcall的规则如下：</strong></p>
<p>① depth的范围合理（Widget的depth值在目标DrawCall的dcStart和dcEnd值之间）</p>
<p>② Widget的material和texture值与目标DrawCall中的值相同</p>
<p>③ Widget可见</p>
<h2 id="UIPanel-LateUpdate"><a href="#UIPanel-LateUpdate" class="headerlink" title="UIPanel.LateUpdate"></a>UIPanel.LateUpdate</h2><p>UIPanel对于Widget的信息写入Geometry缓存、调用DrawCall创建Mesh等操作都是在UIPanel的<code>LateUpdate</code>的生命周期回调内完成的。</p>
<p>其整过程分为两个部分，即：①更新所有UIPanel及其各自部分的组件信息；②更新所有DrawCall并设置正确的绘制顺序。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2952813-fc48fba4a6f46a05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>首先会遍历整个Panel的list，对每一个Panel中的widgets，drawcalls进行更新。</p>
<p>在UIPanel的<code>UpdateSelf</code>中，会进行如下工作：</p>
<ul>
<li>UpdateTransformMatrix: 更新world-to-local变换矩阵</li>
<li>UpdateLayers: 若Panel的layer改变，则更新Widget的layer值</li>
<li>UpdateWidgets: 更新Panel中的所有Widget</li>
</ul>
<p>然后是其中比较重要的方法 <code>FillAllDrawCalls()</code>和<code>FillDrawCall(dc)</code>,如果需要重新构建，则调用前者清空drawCalls并重新创建drawCalls列表并更新Geomerty数据，否则调用后者更新指定DrawCall并更新与之相关的Widget的Geometry数据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2952813-fd5e18a00855ee80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="FillAllDrawCalls"><a href="#FillAllDrawCalls" class="headerlink" title="FillAllDrawCalls"></a>FillAllDrawCalls</h3><p><code>FillAllDrawCalls()</code>会重新创建所有的DrawCall，清空之前所有的DrawCall，按<code>UIWidget.PanelCompareFunc()</code>对所有Widget进行排序。遍历所有Widget，对比该Widget的material、texture和shader是否都与前一个Widget相同，若有不同，则创建一个新的DrawCall；若相同，则合并DrawCall（Draw Call Batching）。完成DrawCall创建后会将Widget中的verts、uvs、cols等信息写入其Geometry中，并调用<code>UIDrawCall.UpdateGeometry</code>创建Mesh、MeshFilter和MeshRender组件去渲染界面元素。</p>
<h3 id="FillDrawCall"><a href="#FillDrawCall" class="headerlink" title="FillDrawCall"></a>FillDrawCall</h3><p><code>FillDrawCall(dc)</code>对指定DrawCall进行更新。遍历所有Widget，若当前Widget所使用的DrawCall与指定DrawCall相同，则更新Widget的Geometry数据，最后同样调用<code>UIDrawCall.UpdateGeometry</code>渲染界面。</p>
<p>因此，LateUpdate回调的整体流程如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2952813-ca44a2a3306595dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>在LateUpdate的最后，会遍历所有的Panel，并对每个Panel中的DrawCall进行更新并设置其renderQueue属性，在进行界面绘制的时候会根据DrawCall的renderQueue值进行有序的绘制。</p>
<h2 id="减少DrawCall数量的建议"><a href="#减少DrawCall数量的建议" class="headerlink" title="减少DrawCall数量的建议"></a>减少DrawCall数量的建议</h2><ol>
<li>同一Panel下的贴图资源尽量打包在一个图集中。</li>
<li>如果同一panel中使用了多个图集，则应当尽量保证使用相同图集的元素在连续的深度范围内，使用不同图集的元素之间尽量不要有深度的穿插。</li>
</ol>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>teddyjiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/06/23/NGUI的面板绘制原理/">https://jygod.github.io/2019/06/23/NGUI的面板绘制原理/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>复制或引用请注明出处</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jygod.github.io/2019/06/23/NGUI的面板绘制原理/" data-id="cjxc0f06p0000mashmu3mlsj5" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACGUlEQVR42u3aS27jMBAFwNz/0prtADNW3mPLBkwWV4FNWCwtOv3hz0+8rn/W35/f709++f6TxxYGBsbXMq7b9epYr3beHzR/Vr4fAwPjHEby+LX98wiZhGkMDAyMJNRGYfE2fK+9MgwMDIy8WM2Ty3sqBgYGxqSIbQvaJOwmgfjhWhwDA+MLGXnX/fN/v2W+gYGB8VWMq1xtcExGCNd4YWBg7M1Ya+Ln1y8mzbj2PBgYGLsy2qCWF5BrDbVk/yg1xMDA2I7RFrRrleY8fGNgYJzASA76jgFkO354GYIxMDC2ZhSVbjmqnIfU/LViYGCcw1gbACQ75yPS4oIFBgbGdox5U6wNym1bLQrQGBgYBzDagjM/3FrpWyejGBgYWzOSYNcWpe2QIEkW6zQRAwPjGEbLaweibXlcvCEMDIztGG3QbMeWE1L+DwADA+MExlqjLb8S0R60XhgYGIcx8hxsLVBORgh1+YqBgbERYzKwfKplliOjC2EYGBjbMSahdpL2rZXE//kWAwPjSMb8kkRbvhbhFQMDAyOeEuaPTKijfhoGBsamjKtcecH5mTYcBgbGCYxnhwFt2y5PK+fBHQMD49sZk3D57GCg3VMkiBgYGFsw2sDXpozzInY0GMDAwDiMkTTg8sFA/stR0w0DAwPjDeOBPDT/UgZjYGAcwMgbas+mfY+FYwwMjK0Zn7wY0Y4WFtNEDAyMfRh/AEzTapieL54CAAAAAElFTkSuQmCC">分享</a><div class="tags"></div><div class="post-nav"><a class="next" href="/2019/06/23/深入Lua-字符串/">深入Lua - 字符串</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'cf798d30d92e03b58c26',
  clientSecret: '4d72762fd21fa367c3c9836b9641301ea3272650',
  repo: 'jygod.github.io',
  owner: 'JYGod',
  admin: ['JYGod'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://jygod.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Lua/">Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NGUI/">NGUI</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/23/NGUI的面板绘制原理/">NGUI的面板绘制原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/23/深入Lua-字符串/">深入Lua - 字符串</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/jygod/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://www.jianshu.com/u/b4d7ac8c1b81" title="简书" target="_blank">简书</a><ul></ul><a href="https://github.com/JYGod" title="Github" target="_blank">Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Teddyjiang的技术博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>